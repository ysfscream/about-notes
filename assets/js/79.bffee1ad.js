(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{344:function(e,_,v){"use strict";v.r(_);var r=v(0),o=Object(r.a)({},function(){var e=this,_=e.$createElement,v=e._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"docker-简单使用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#docker-简单使用","aria-hidden":"true"}},[e._v("#")]),e._v(" Docker 简单使用")]),e._v(" "),v("p",[v("a",{attrs:{href:"http://www.runoob.com/docker/docker-tutorial.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考1"),v("OutboundLink")],1)]),e._v(" "),v("p",[v("a",{attrs:{href:"https://www.gitbook.com/book/yeasy/docker_practice/details",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考2"),v("OutboundLink")],1)]),e._v(" "),v("blockquote",[v("p",[e._v("Docker 是一个开源的应用容器引擎，基于 "),v("a",{attrs:{href:"http://www.runoob.com/go/go-tutorial.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Go 语言"),v("OutboundLink")],1),e._v(" 并遵从Apache2.0协议开源。")]),e._v(" "),v("p",[e._v("Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。")]),e._v(" "),v("p",[e._v("容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低")])]),e._v(" "),v("p",[e._v("Docker 容器通过 Docker 镜像来创建")]),e._v(" "),v("p",[e._v("容器与镜像的关系类似于面向对象编程中的对象与类")]),e._v(" "),v("p",[e._v("当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载")]),e._v(" "),v("h2",{attrs:{id:"镜像"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#镜像","aria-hidden":"true"}},[e._v("#")]),e._v(" 镜像")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("docker images")]),e._v("查看本机主机上的镜像")]),e._v(" "),v("li",[v("code",[e._v("docker pull xxx(ubuntu, nginx...)")]),e._v("获取一个新的镜像")]),e._v(" "),v("li",[v("code",[e._v("docker image rm [选项] <镜像1> [<镜像2> …]")]),e._v(" 删除本地镜像\n"),v("ul",[v("li",[e._v("用 ID、镜像名、摘要删除镜像 "),v("code",[e._v("<镜像>")]),e._v(" 可以是 "),v("code",[e._v("镜像短 ID")]),e._v("、"),v("code",[e._v("镜像长 ID")]),e._v("、"),v("code",[e._v("镜像名")]),e._v(" 或者 "),v("code",[e._v("镜像摘要")])])])])]),e._v(" "),v("h2",{attrs:{id:"容器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#容器","aria-hidden":"true"}},[e._v("#")]),e._v(" 容器")]),e._v(" "),v("p",[e._v("启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（"),v("code",[e._v("stopped")]),e._v("）的容器重新启动。")]),e._v(" "),v("p",[e._v("因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("所需要的命令主要为 "),v("code",[e._v("docker run")]),e._v("，我们可以直接使用这个镜像来运行容器。这是新建启动")])]),e._v(" "),v("li",[v("p",[e._v("当利用 "),v("code",[e._v("docker run")]),e._v(" 来创建容器时，Docker 在后台运行的标准操作包括：")]),e._v(" "),v("ul",[v("li",[e._v("检查本地是否存在指定的镜像，不存在就从公有仓库下载")]),e._v(" "),v("li",[e._v("利用镜像创建并启动一个容器")]),e._v(" "),v("li",[e._v("分配一个文件系统，并在只读的镜像层外面挂载一层可读写层")]),e._v(" "),v("li",[e._v("从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去")]),e._v(" "),v("li",[e._v("从地址池配置一个 ip 地址给容器")]),e._v(" "),v("li",[e._v("执行用户指定的应用程序")]),e._v(" "),v("li",[e._v("执行完毕后容器被终止")])])]),e._v(" "),v("li",[v("p",[e._v("可以尝试运行一个 "),v("a",{attrs:{href:"https://store.docker.com/images/nginx/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Nginx 服务器"),v("OutboundLink")],1)]),e._v(" "),v("div",{staticClass:"language-shell extra-class"},[v("pre",{pre:!0,attrs:{class:"language-shell"}},[v("code",[e._v("docker run -d -p "),v("span",{pre:!0,attrs:{class:"token number"}},[e._v("80")]),e._v(":80 --name webserver nginx\n")])])]),v("ul",[v("li",[e._v("**-d:**让容器在后台运行。此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 "),v("code",[e._v("docker logs")]),e._v("查看")]),e._v(" "),v("li",[e._v("**-P 80： 80:**将容器内部使用的网络端口映射到我们使用的主机上")]),e._v(" "),v("li",[v("strong",[e._v("—name webserver")]),e._v("  将容器命名为 webserver")])])]),e._v(" "),v("li",[v("p",[v("code",[e._v("docker ps")]),e._v(" "),v("code",[e._v("docker container ls")]),e._v(" 命令来查看运行的容器信息")])]),e._v(" "),v("li",[v("p",[e._v("要获取容器的输出信息，可以通过 "),v("code",[e._v("docker container logs")]),e._v(" 命令")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("docker container start")]),e._v(" 命令，直接将一个已经终止的容器启动运行。")])]),e._v(" "),v("li",[v("p",[e._v("可以使用 "),v("code",[e._v("docker container stop")]),e._v(" 来终止一个运行中的容器。")])]),e._v(" "),v("li",[v("p",[e._v("终止状态的容器可以用 "),v("code",[e._v("docker container ls -a")]),e._v(" "),v("code",[e._v("docker p -l")]),e._v("命令看到")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("docker container restart")]),e._v(" 命令会将一个运行态的容器终止，然后再重新启动它")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("docker exec")]),e._v(" 命令进入容器进行操作")]),e._v(" "),v("ul",[v("li",[v("p",[v("code",[e._v("docker exec")]),e._v(" 后边可以跟多个参数，这里主要说明 "),v("code",[e._v("-i")]),e._v(" "),v("code",[e._v("-t")]),e._v(" 参数。")]),e._v(" "),v("p",[e._v("只用 "),v("code",[e._v("-i")]),e._v(" 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。")]),e._v(" "),v("p",[e._v("当 "),v("code",[e._v("-i")]),e._v(" "),v("code",[e._v("-t")]),e._v(" 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符")])])])]),e._v(" "),v("li",[v("p",[e._v("如果要导出本地某个容器，可以使用 "),v("code",[e._v("docker export")]),e._v(" 命令")])]),e._v(" "),v("li",[v("p",[e._v("可以使用 "),v("code",[e._v("docker import")]),e._v(" 从容器快照文件中再导入为镜像，也可以通过指定 URL 或者某个目录来导入，例如"),v("code",[e._v("docker import http://example.com/exampleimage.tgz example/imagerepo")])])]),e._v(" "),v("li",[v("p",[e._v("可以使用 "),v("code",[e._v("docker container rm")]),e._v(" 来删除一个处于终止状态的容器如果要删除一个运行中的容器，可以添加 "),v("code",[e._v("-f")]),e._v(" 参数。Docker 会发送 "),v("code",[e._v("SIGKILL")]),e._v(" 信号给容器。")])]),e._v(" "),v("li",[v("p",[e._v("用 "),v("code",[e._v("docker container ls -a")]),e._v(" 命令可以查看所有已经创建的包括终止状态的容器，下面的命令可以清理掉所有处于终止状态的容器。"),v("code",[e._v("docker container prune")])])])])])},[],!1,null,null,null);_.default=o.exports}}]);