(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{217:function(e,r,t){"use strict";t.r(r);var a=t(0),i=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"web-状态与无状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#web-状态与无状态","aria-hidden":"true"}},[e._v("#")]),e._v(" Web 状态与无状态")]),e._v(" "),t("p",[e._v("原文：https://blog.csdn.net/Jmilk/article/details/50461577")]),e._v(" "),t("h2",{attrs:{id:"基于状态的web服务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基于状态的web服务","aria-hidden":"true"}},[e._v("#")]),e._v(" 基于状态的Web服务")]),e._v(" "),t("p",[e._v("在基于状态的Web服务中，Client与Server交互的信息(如：用户登录状态)会保存在Server的Session中。再这样的前提下，Client中的用户请求只能被保存有此用户相关状态信息的服务器所接受和理解，这也就意味着在基于状态的Web系统中的Server无法对用户请求进行负载均衡等自由的调度(一个Client请求只能由一个指定的Server处理)。同时这也会导致另外一个容错性的问题，如果指定的Server在Client的用户发出请求的过程中宕机，那么此用户最近的所有交互操作将无法被转移至别的Server上，即此请求将无效化。")]),e._v(" "),t("h2",{attrs:{id:"基于无状态的web服务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基于无状态的web服务","aria-hidden":"true"}},[e._v("#")]),e._v(" 基于无状态的Web服务")]),e._v(" "),t("p",[e._v("在无状态的Web服务中，每一个Web请求都必须是独立的，请求之间是完全分离的。Server没有保存Client的状态信息，所以Client发送的请求必须包含有能够让服务器理解请求的全部信息，包括自己的状态信息。使得一个Client的Web请求能够被任何可用的Server应答，从而将Web系统扩展到大量的Client中。")]),e._v(" "),t("h2",{attrs:{id:"区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#区别","aria-hidden":"true"}},[e._v("#")]),e._v(" 区别")]),e._v(" "),t("p",[e._v("因为无状态原则的特性，让RESTful在分布式系统中得到了广泛的应用，它改善了分布式系统的可见性、可靠性以及可伸缩性，同时有效的降低了Client与Server之间的交互延迟。无状态的请求有利于实现负载均衡，在分布式web系统下，有多个可的Server，每个Server都可以处理Client发送的请求。有状态的请求的状态信息只保存在第一次接收请求的Server上，所以后来同一个Client的请求都只能由这台Server来处理，Server无法自由调度请求。无状态请求则完全没有这个限制。其次，无状态请求有较强的容错性和可伸缩性。如果一台服务器宕机，无状态请求可以透明地交由另一台可用Server来处理，而有状态的请求则会因为存储请求状态信息的Server宕机而承担状态丢失的风险。Restful风格的无状态约束要求Server不保存请求状态，如果确实需要维持用户状态，也应由Client负责。")])])}],!1,null,null,null);i.options.__file="Web 状态与无状态.md";r.default=i.exports}}]);