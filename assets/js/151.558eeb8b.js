(window.webpackJsonp=window.webpackJsonp||[]).push([[151],{211:function(a,e,t){"use strict";t.r(e);var r=t(0),v=Object(r.a)({},function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"面试整理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面试整理","aria-hidden":"true"}},[a._v("#")]),a._v(" 面试整理")]),a._v(" "),t("h2",{attrs:{id:"javascript"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javascript","aria-hidden":"true"}},[a._v("#")]),a._v(" Javascript")]),a._v(" "),t("h3",{attrs:{id:"闭包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#闭包","aria-hidden":"true"}},[a._v("#")]),a._v(" 闭包")]),a._v(" "),t("p",[a._v("所以，我们说的闭包，就是能够在外部访问函数内部的函数。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。\n闭包是在一个函数里声明了另外一个函数，并且这个函数访问了父函数作用域里的变量\n闭包允许将函数与其所操作的某些数据（环境）关连起来。这显然类似于面向对象编程。在面对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。因而，一般说来，可以使用只有一个方法的对象的地方，都可以使用闭包。")]),a._v(" "),t("h3",{attrs:{id:"在严格模式-use-strict-下进行-javascript-开发有什么好处"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#在严格模式-use-strict-下进行-javascript-开发有什么好处","aria-hidden":"true"}},[a._v("#")]),a._v(" 在严格模式('use strict')下进行 JavaScript 开发有什么好处")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;")])]),a._v(" "),t("li",[t("p",[a._v("消除代码运行的一些不安全之处，保证代码运行的安全；")])]),a._v(" "),t("li",[t("p",[a._v("提高编译器效率，增加运行速度；")])]),a._v(" "),t("li",[t("p",[a._v("为未来新版本的 Javascript 做好铺垫。")])])]),a._v(" "),t("h3",{attrs:{id:"ajax"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ajax","aria-hidden":"true"}},[a._v("#")]),a._v(" Ajax")]),a._v(" "),t("p",[a._v("简述 AJAX：AJAX 即 “Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。")]),a._v(" "),t("p",[a._v("AJAX 基本步骤：")]),a._v(" "),t("ol",[t("li",[a._v("初始化ajax对象")]),a._v(" "),t("li",[a._v("连接地址，准备数据")]),a._v(" "),t("li",[a._v("发送请求")]),a._v(" "),t("li",[a._v("接收数据（正在接收，尚未完成）")]),a._v(" "),t("li",[a._v("接收数据完成")])]),a._v(" "),t("h2",{attrs:{id:"网络"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网络","aria-hidden":"true"}},[a._v("#")]),a._v(" 网络")]),a._v(" "),t("h3",{attrs:{id:"http报文头部有哪些字段-有什么意义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http报文头部有哪些字段-有什么意义","aria-hidden":"true"}},[a._v("#")]),a._v(" http报文头部有哪些字段? 有什么意义")]),a._v(" "),t("p",[a._v("请求头（Request）：")]),a._v(" "),t("ul",[t("li",[a._v("Accept：text/html application/xml 告诉服务器客户端浏览器这边可以出里什么数据；")]),a._v(" "),t("li",[a._v("Accept-Encodeing：gzip 告诉服务器我能支持什么样的压缩格式")]),a._v(" "),t("li",[a._v("Accept-language：告诉服务器浏览器支持的语言")]),a._v(" "),t("li",[a._v("Cache-control：告诉服务器是否缓存")]),a._v(" "),t("li",[a._v("Connection:keep-alive 告诉服务器当前保持活跃（与服务器处于链接状态）")]),a._v(" "),t("li",[a._v("Host：远程服务器的域名")]),a._v(" "),t("li",[a._v("User-agent：客户端的一些信息，浏览器信息 版本")]),a._v(" "),t("li",[a._v("referer：当前页面上一个页面地址。一般用于服务器判断是否为同一个域名下的请求")])]),a._v(" "),t("h3",{attrs:{id:"tcp三次握手与四次挥手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp三次握手与四次挥手","aria-hidden":"true"}},[a._v("#")]),a._v(" TCP三次握手与四次挥手")]),a._v(" "),t("p",[a._v("所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("第一次握手(SYN=1, seq=x):\n客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。\n发送完毕后，客户端进入 SYN_SEND 状态。")])]),a._v(" "),t("li",[t("p",[a._v("第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):\n服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。")])]),a._v(" "),t("li",[t("p",[a._v("第三次握手(ACK=1，ACKnum=y+1)\n客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1\n发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED状态，TCP 握手结束。")])])]),a._v(" "),t("h3",{attrs:{id:"udp-是一个简单的传输层协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#udp-是一个简单的传输层协议","aria-hidden":"true"}},[a._v("#")]),a._v(" UDP 是一个简单的传输层协议")]),a._v(" "),t("p",[a._v("和 TCP 相比，UDP 有下面几个显著特性：")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("UDP 缺乏可靠性。UDP 本身不提供确认，序列号，超时重传等机制。UDP 数据报可能在网络中被复制，被重新排序。即 UDP 不保证数据报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次")])]),a._v(" "),t("li",[t("p",[a._v("UDP 数据报是有长度的。每个 UDP 数据报都有长度，如果一个数据报正确地到达目的地，那么该数据报的长度将随数据一起传递给接收方。而 TCP 是一个字节流协议，没有任何（协议上的）记录边界。")])]),a._v(" "),t("li",[t("p",[a._v("UDP 是无连接的。UDP 客户和服务器之前不必存在长期的关系。UDP 发送数据报之前也不需要经过握手创建连接的过程。")])]),a._v(" "),t("li",[t("p",[a._v("UDP 支持多播和广播。")])])]),a._v(" "),t("h3",{attrs:{id:"url-输入到呈现的过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#url-输入到呈现的过程","aria-hidden":"true"}},[a._v("#")]),a._v(" URL 输入到呈现的过程")]),a._v(" "),t("p",[t("img",{attrs:{src:"/about-notes/media/url-browser.jpg",alt:"short"}})]),a._v(" "),t("h2",{attrs:{id:"vue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue","aria-hidden":"true"}},[a._v("#")]),a._v(" Vue")]),a._v(" "),t("h3",{attrs:{id:"vue-数据双向绑定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-数据双向绑定","aria-hidden":"true"}},[a._v("#")]),a._v(" vue 数据双向绑定")]),a._v(" "),t("p",[a._v("vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的\n因为vue是通过Object.defineProperty()来实现数据劫持的。")]),a._v(" "),t("p",[a._v("Object.defineProperty( )是用来做什么的？它可以来控制一个对象属性的一些特有操作，比如读写权、是否可以枚举，这里我们主要先来研究下它对应的两个描述属性get和set，如果还不熟悉其用法")]),a._v(" "),t("p",[a._v("通过Object.defineProperty( )对属性设置一个set函数，当数据改变了就会来触发这个函数")]),a._v(" "),t("h3",{attrs:{id:"template-和-render-函数的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#template-和-render-函数的区别","aria-hidden":"true"}},[a._v("#")]),a._v(" template 和 render 函数的区别")]),a._v(" "),t("ul",[t("li",[a._v("Template适合逻辑简单，render适合复杂逻辑。")]),a._v(" "),t("li",[a._v("使用者template理解起来相对容易，但灵活性不足；自定义render函数灵活性高，但对使用者要求较高。")]),a._v(" "),t("li",[a._v("render的性能较高，template性能较低。这一点我们可以看一下，下图中vue组件渲染的流程图可知。")]),a._v(" "),t("li",[a._v("基于上一点，我们通过vue组件渲染流程图知道，使用render函数渲染没有编译过程，相当于使用者直接将代码给程序。所以，使用它对使用者要求高，且易出现错误")]),a._v(" "),t("li",[a._v("Render 函数的优先级要比template的级别要高，但是要注意的是Mustache(双花括号)语法就不能再次使用")])]),a._v(" "),t("h2",{attrs:{id:"前端知识点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端知识点","aria-hidden":"true"}},[a._v("#")]),a._v(" 前端知识点")]),a._v(" "),t("h3",{attrs:{id:"diff-算法-虚拟dom"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#diff-算法-虚拟dom","aria-hidden":"true"}},[a._v("#")]),a._v(" diff 算法 虚拟dom")]),a._v(" "),t("p",[a._v("所谓的 virtual dom，也就是虚拟节点。它通过JS的Object对象模拟DOM中的节点，然后再通过特定的render方法将其渲染成真实的DOM节点\ndom diff 则是通过JS层面的计算，返回一个patch对象，即补丁对象，在通过特定的操作解析patch对象，完成页面的重新渲染\n比较两棵DOM树的差异是Virtual DOM算法最核心的部分.简单的说就是新旧虚拟dom 的比较，如果有差异就以新的为准，然后再插入的真实的dom中，重新渲染。\n1、此节点是否被移除 -> 添加新的节点\n2、属性是否被改变 -> 旧属性改为新属性\n3、文本内容被改变-> 旧内容改为新内容\n4、节点要被整个替换 -> 结构完全不相同 移除整个替换")]),a._v(" "),t("h3",{attrs:{id:"服务端渲染和客户端渲染区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#服务端渲染和客户端渲染区别","aria-hidden":"true"}},[a._v("#")]),a._v(" 服务端渲染和客户端渲染区别")]),a._v(" "),t("p",[a._v("服务端渲染作用是啥 【SEO友好，首屏渲染速度等】直出HTML，通过render函数将VirtualDom渲染模板")]),a._v(" "),t("h2",{attrs:{id:"electron"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#electron","aria-hidden":"true"}},[a._v("#")]),a._v(" Electron")]),a._v(" "),t("h3",{attrs:{id:"electron-原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#electron-原理","aria-hidden":"true"}},[a._v("#")]),a._v(" Electron 原理")]),a._v(" "),t("p",[a._v("Electron 结合了 Chromium、Node.js 和用于调用操作系统本地功能的 API（如打开文件窗口、通知、图标等）。\nAPI：应用程序接口（Application Program Interface）描述了库提供的函数集。\nChromium：Google 创造的一个开源库，并用于 Google 的浏览器 Chrome。\nNode.js（Node）：一个在服务器运行 JavaScript 的运行时（runtime），它拥有访问文件系统和网络权限（你的电脑也可以是一台服务器！）")]),a._v(" "),t("h3",{attrs:{id:"electron-分为渲染进程和主进程的好处"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#electron-分为渲染进程和主进程的好处","aria-hidden":"true"}},[a._v("#")]),a._v(" Electron 分为渲染进程和主进程的好处")]),a._v(" "),t("h2",{attrs:{id:"工具类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#工具类","aria-hidden":"true"}},[a._v("#")]),a._v(" 工具类")]),a._v(" "),t("h3",{attrs:{id:"webpack-的原理-loader-和-plugin-是干什么的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack-的原理-loader-和-plugin-是干什么的","aria-hidden":"true"}},[a._v("#")]),a._v(" webpack 的原理, loader 和 plugin 是干什么的")]),a._v(" "),t("p",[a._v("webpack 是一个现代 JavaScript 应用程序的模块打包器(module bundler)")]),a._v(" "),t("p",[a._v("之前的代码都是通过外引的方式引入 HTML 中  打包就是将这些各类文件按功能需求打包成不同的模块 通过配置 webpack.config.js(默认导出module.export) 入口 entry 出口 output module 里的 loader 配置打包其他文件\nWebpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。")]),a._v(" "),t("p",[a._v("相对于 loader 转换指定类型的模块功能，plugins 能够被用于执行更广泛的任务比如打包优化、文件管理、环境注入等……\nloader，它是一个转换器，将A文件进行编译成B文件，比如：将 A.less 转换为 A.css，单纯的文件转换过程。\nplugin 是一个扩展器，它丰富了 webpack 本身，针对是 loader 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务")])])},[],!1,null,null,null);e.default=v.exports}}]);