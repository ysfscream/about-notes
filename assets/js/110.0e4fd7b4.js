(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{387:function(e,t,a){"use strict";a.r(t);var r=a(0),s=Object(r.a)({},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"webpack-打包压缩后的文件名的hash值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack-打包压缩后的文件名的hash值","aria-hidden":"true"}},[e._v("#")]),e._v(" webpack 打包压缩后的文件名的hash值")]),e._v(" "),a("p",[e._v("我们使用 webpack 来打包我们的模块化后的应用程序，webpack 会生成一个可部署的"),a("code",[e._v("/dist")]),e._v("目录，然后把打包后的内容放置在此目录中。只要"),a("code",[e._v("/dist")]),e._v("目录中的内容部署到服务器上，客户端（通常是浏览器）就能够访问网站此服务器的网站及其资源。而最后一步获取资源是比较耗费时间的，这就是为什么浏览器使用一种名为"),a("a",{attrs:{href:"https://searchstorage.techtarget.com/definition/cache",target:"_blank",rel:"noopener noreferrer"}},[e._v("缓存"),a("OutboundLink")],1),e._v("的技术。可以通过命中缓存，以降低网络流量，使网站加载速度更快，然而，如果我们在部署新版本时不更改资源的文件名，浏览器可能会认为它没有被更新，就会使用它的缓存版本。由于缓存的存在，当你需要获取新的代码时，就会显得很棘手。")]),e._v(" "),a("p",[e._v("此指南的重点在于通过必要的配置，以确保 webpack 编译生成的文件能够被客户端缓存，而在文件内容变化后，能够请求到新的文件。")]),e._v(" "),a("p",[e._v("指南 -> https://webpack.docschina.org/guides/caching/")]),e._v(" "),a("p",[e._v("打包后的文件名的hash值 最长用的一个使用浏览器缓存的方法，它相当于一个版本号 版本没变则根据hash值获取长缓存，版本号改变则重新获取。")])])},[],!1,null,null,null);t.default=s.exports}}]);